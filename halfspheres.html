<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three base64 embedded image</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    //import * as THREE from 'three';

    // Initialisation de la scène
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    // Initialisation de la caméra
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Initialisation du rendu
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Créer une géométrie de sphère
    const radius = 2;
    const widthSegments = 32;
    const heightSegments = 32;
    const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);

    // Récupérer les positions et les indices
    const positionAttribute = geometry.attributes.position;
    const indexAttribute = geometry.index;

    // Créer deux groupes de faces
    const leftFaces = [];
    const rightFaces = [];

    // Parcourir les faces (chaque face est composée de 3 sommets)
    for (let i = 0; i < indexAttribute.count; i += 3) {
      const a = indexAttribute.array[i];
      const b = indexAttribute.array[i + 1];
      const c = indexAttribute.array[i + 2];

      // Récupérer les positions des sommets de la face
      const ax = positionAttribute.array[a * 3];
      const bx = positionAttribute.array[b * 3];
      const cx = positionAttribute.array[c * 3];

      // Calculer le centroïde de la face (approximation)
      const centroidX = (ax + bx + cx) / 3;

      // Si le centroïde est à gauche (x < 0), ajouter la face au groupe gauche
      if (centroidX < 0) {
        leftFaces.push(i / 3);
      } else {
        // Sinon, ajouter la face au groupe droit
        rightFaces.push(i / 3);
      }
    }

    // Convertir les listes de faces en tableaux de counts et starts
    const leftCount = leftFaces.length * 3;
    const rightCount = rightFaces.length * 3;

    // Créer les groupes
    geometry.groups = [
      {
        start: 0,
        count: leftCount,
        materialIndex: 0, // Utilisera le premier matériau
      },
      {
        start: leftCount,
        count: rightCount,
        materialIndex: 1, // Utilisera le deuxième matériau
      },
    ];

    // Réorganiser les indices pour regrouper les faces
    const newIndices = [];
    leftFaces.forEach(faceIndex => {
      newIndices.push(
        indexAttribute.array[faceIndex * 3],
        indexAttribute.array[faceIndex * 3 + 1],
        indexAttribute.array[faceIndex * 3 + 2]
      );
    });
    rightFaces.forEach(faceIndex => {
      newIndices.push(
        indexAttribute.array[faceIndex * 3],
        indexAttribute.array[faceIndex * 3 + 1],
        indexAttribute.array[faceIndex * 3 + 2]
      );
    });

    // Mettre à jour les indices de la géométrie
    geometry.setIndex(newIndices);

    function changeUV(geometry) {
      const uvs = geometry.attributes.uv.array;
      for (let i = 0; i < uvs.length; i += 2) {
        uvs[i] *= 0.5; // Limiter la texture à la moitié de la largeur
      }
      geometry.attributes.uv.needsUpdate = true;
    }
    //changeUV(geometry)


    // Charger les textures
    const textureLoader = new THREE.TextureLoader();
    const textureLeft = textureLoader.load('textures/Alia00.jpg'); // Remplacez par votre texture
    const textureRight = textureLoader.load('textures/Pepette.jpg'); // Remplacez par votre texture
     
    function changeSet(texture, a, b, c, d) {
      texture.repeat.set(a, b);
      texture.offset.set(c, d);
    }

    changeSet(textureLeft, 0.5, 1, 0, 0);
    changeSet(textureRight, 0.5, 1, 0.5, 0);

    // Créer deux matériaux avec des textures différentes
    const materialLeft = new THREE.MeshPhongMaterial({
      map: textureLeft,
      color: 0xffffff,
    });

    const materialRight = new THREE.MeshPhongMaterial({
      map: textureRight,
      color: 0xffffff,
    });

    const materials = [materialLeft, materialRight];

    // Créer le mesh avec les deux matériaux
    const mesh = new THREE.Mesh(geometry, materials);
    scene.add(mesh);

    // Ajouter une lumière
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1);
    scene.add(light);

    // Animation
    function animate() {
      requestAnimationFrame(animate);
      mesh.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    // Gestion du redimensionnement de la fenêtre
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>

</html>