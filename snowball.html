<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boule à Neige</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script>

                       // Fonction pour vérifier si un point est à l'intérieur de la boule
        function getInitialFlakeCoordinates() {
            pi=Math.PI
            return ({
               'xtheta' : Math.random() * Math.PI * 2,
               'theta' : pi/2,
               'phi' : Math.random() * pi *2,
               'xxphi' : Math.PI/8,
               'xphi': Math.acos(2 * Math.random() - 1)
            });
        }

        function getFlakeXYZ(radius,theta,phi) {
            x=radius * Math.sin(theta) * Math.cos(phi);
            y=radius * Math.sin(theta) * Math.sin(phi);
            z=radius * Math.cos(theta);
            //console.log(radius,'theta',theta.toFixed(2),'phi',phi.toFixed(2),'x',x.toFixed(2),'y',y.toFixed(2),'z',z.toFixed(2))
            return({'x' : x, 'y':y, 'z' : z})
        }

        function posTab() {
            for (let theta=0; theta<2*Math.PI; theta += Math.PI/3) {
              for (let phi=0; phi<2*Math.PI; phi += Math.PI/3) {
                getFlakeXYZ(1,theta,phi)
              }
            }
        }
        //posTab()
        //alert("xx")

        // Fonction pour vérifier si un point est à l'intérieur de la boule
        function isInsideSphere(x, y, z, radius) {
            return (x * x + y * y + z * z) <= (radius * radius);
        }

        // Initialisation de la scène
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Initialisation de la caméra
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            1,
            10000
        );
        camera.position.z = 10;

        // Initialisation du rendu
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Ajout des contrôles OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Rayon de la boule à neige
        const snowGlobeRadius = 5;

        // Point zero
        const zeroGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const zeroMaterial = new THREE.MeshPhongMaterial({
            color: 0xffff00,
            size: 0.1,
            transparent: false,
            opacity: 0.8,
            depthTest: false,
            depthWrite: true,
        });
        const zeroMesh = new THREE.Mesh(zeroGeometry, zeroMaterial);

        // Création de la boule à neige (sphère transparente)
        const snowGlobeGeometry = new THREE.SphereGeometry(snowGlobeRadius, 32, 32);
        const snowGlobeMaterial = new THREE.MeshPhongMaterial({
            color: 0x77b5fe,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide,
        });

        // Création sphère intérieure)
        const textureLoader = new THREE.TextureLoader()
        const texture = textureLoader.load('textures/maison.jpg')
        const snowGlobeGeometryIn = new THREE.SphereGeometry(snowGlobeRadius * 0.97, 32, 32);
        const snowGlobeMaterialIn = new THREE.MeshPhongMaterial({
            map: texture,
            transparent: false,
            opacity: 1,
            side: THREE.DoubleSide,
        });

        const snowGlobe = new THREE.Mesh(snowGlobeGeometry, snowGlobeMaterial);
        const snowGlobeIn = new THREE.Mesh(snowGlobeGeometryIn, snowGlobeMaterialIn);
        scene.add(snowGlobeIn)

        // Création d'un objet central (par exemple, un arbre de Noël)
        const treeGeometry = new THREE.ConeGeometry(1, 3, 8);
        const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x006400 });
        const tree = new THREE.Mesh(treeGeometry, treeMaterial);
        tree.position.y = -1.5;
        //snowGlobe.add(tree);

        // Ajjout fils de fer
        const wireMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            wireframe: true
        })
        const wireMesh = new THREE.Mesh(snowGlobeGeometry, wireMat)
        //snowGlobe.add(wireMesh)
        //scene.add(wireMesh)

        // Création des flocons de neige
        const flakeCount = 300;

        // Tableaux pour les positions et vitesses des flocons
        const flakePositions = new Float32Array(flakeCount * 3);
        const flakeSpeeds = new Float32Array(flakeCount);
        const flakeSwaySpeedsX = new Float32Array(flakeCount);
        const flakeSwaySpeedsZ = new Float32Array(flakeCount);

        // Initialisation des flocons
        for (let i = 0; i < flakeCount; i++) {
            // Position aléatoire à l'intérieur de la boule
            const radius = snowGlobeRadius * 0.97;
            const angles=getInitialFlakeCoordinates()
            const pos=getFlakeXYZ(radius,angles.theta,angles.phi)
            flakePositions[i * 3] = pos.x
            flakePositions[i * 3 + 1] = pos.y
            flakePositions[i * 3 + 2] = pos.z

            // Vitesse de chute aléatoire
            flakeSpeeds[i] = 0.01 + Math.random() * 0.03;
            flakeSwaySpeedsX[i] = (Math.random() - 0.5) * 0.01;
            flakeSwaySpeedsZ[i] = (Math.random() - 0.5) * 0.01;
        }
        const flakeGeometry = new THREE.BufferGeometry();
        const flakeMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: false,
            opacity: 0.8,
            depthTest: false,
            depthWrite: true,
        });

        const XflakeGeometry = new THREE.SphereGeometry(0.8, 8,8)
        const XflakeMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8,
        });

        flakeGeometry.setAttribute('position', new THREE.BufferAttribute(flakePositions, 3));
        const flakes = new THREE.Points(flakeGeometry, flakeMaterial);
        const Xflakes = new THREE.Mesh(flakeGeometry, flakeMaterial, flakeCount);
        //flakes.renderOrder = 99; // Les particules seront rendues après les autres objets
        snowGlobe.add(flakes);
        //scene.add(flakes)

 
        snowGlobeIn.renderOrder = 0; // La photo sera rendue en premier

        //scene.add(flakes)
        scene.add(snowGlobe);
        zeroMesh.renderOrder = 100
        //scene.add(zeroMesh)

        // Ajouter une lumière ambiante
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);


        // Ajouter une lumière ambiante
        const hemiLight = new THREE.HemisphereLight(0xaa5500, 0x0099ff);
        //scene.add(hemiLight);

        // Ajouter une lumière directionnelle
        const directionalLight = new THREE.DirectionalLight(0xaa55ff, 0.8);
        directionalLight.position.set(10, 10, 1);
        scene.add(directionalLight);

        //const gltfLoader = new THREE.GLTFLoader();
        // Charger un modèle 3D
        //gltfLoader.load(
        //  'textures/chess.glb',
        //  (gltf) => {
        //    const model = gltf.scene;
        //    model.scale.set(8,8,8);
        //   model.position.y = -2;
        //    snowGlobe.add(model);
        //    console.log("gltf loaded")
        //  }
        //);


        function animate() {
            requestAnimationFrame(animate);

            // Faire tourner la boule à neige lentement
            snowGlobeIn.rotation.y += 0.002;

            // Animer les flocons de neige
            const positions = flakes.geometry.attributes.position.array;
            for (let i = 0; i < flakeCount; i++) {
                // Index dans le tableau des positions

                const index = i * 3;
                //console.log(i,positions[index + 1])
                // Faire tomber le flocon
                positions[index + 1] -= flakeSpeeds[i];

                // Balancement latéral
                positions[index] += flakeSwaySpeedsX[i];
                positions[index + 2] += flakeSwaySpeedsZ[i];

                // Vérifier si le flocon est sorti de la boule
                if (!isInsideSphere(positions[index], positions[index + 1], positions[index + 2], snowGlobeRadius * 1)) {
                    // Replacer le flocon à une position aléatoire à l'intérieur de la boule
                    console.log("Flake out")
                    const radius = snowGlobeRadius * 1;
                    const angles=getInitialFlakeCoordinates()
                    const pos=getFlakeXYZ(radius,angles.theta,angles.phi)
                    flakePositions[i * 3] = pos.x
                    flakePositions[i * 3 + 1] = pos.y
                    flakePositions[i * 3 + 2] = pos.z
                }
            }

            // Indiquer que les positions des flocons ont été mises à jour
            flakes.geometry.attributes.position.needsUpdate = true;

            controls.update();
            renderer.render(scene, camera);
        }

        // Animation
function Xanimate() {
      requestAnimationFrame(animate);

      // Faire tourner la boule à neige lentement
      snowGlobe.rotation.y += 0.002;

      // Animer les flocons de neige
      flakes.children.forEach(flake => {
        // Faire tomber le flocon
        flake.position.y -= flake.userData.speed;

        // Balancement latéral
        flake.position.x += flake.userData.swaySpeedX;
        flake.position.z += flake.userData.swaySpeedZ;

        // Faire tourner le flocon sur lui-même
        flake.rotation.x += 0.01;
        flake.rotation.y += 0.01;

        // Vérifier si le flocon est sorti de la boule
        if (!isInsideSphere(flake.position.x, flake.position.y, flake.position.z, snowGlobeRadius * 0.9)) {
          // Replacer le flocon à une position aléatoire à l'intérieur de la boule
          const radius = snowGlobeRadius * 0.8;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          flake.position.x = radius * Math.sin(phi) * Math.cos(theta);
          flake.position.y = radius * Math.sin(phi) * Math.sin(theta);
          flake.position.z = radius * Math.cos(phi);
        }
      });
      // Indiquer que les positions des flocons ont été mises à jour
            flakes.geometry.attributes.position.needsUpdate = true;

      controls.update();
      renderer.render(scene, camera);
    }

        animate();



        // Gestion du redimensionnement de la fenêtre
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>