<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boule à Neige</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    // Initialisation de la scène
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Initialisation de la caméra
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 10;

    // Initialisation du rendu
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Ajout des contrôles OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Rayon de la boule à neige
    const snowGlobeRadius = 5;

    const textureLoader=new THREE.TextureLoader()
    const texture=textureLoader.load('textures/maison.jpg')
    //const sphereMaterial = new THREE.MeshStandardMaterial({
    //  map: texture,
    //  metalness: 0.1,
    //  roughness: 0.7,
    //});

    // Création de la boule à neige (sphère transparente)
    const snowGlobeGeometry = new THREE.SphereGeometry(snowGlobeRadius, 32, 32);
    const snowGlobeMaterial = new THREE.MeshPhongMaterial({
      //map : texture,
      //color: 0xaaeeff,
      transparent: false,
      opacity: 0.9,
      //side: THREE.DoubleSide,
    });
    const snowGlobe = new THREE.Mesh(snowGlobeGeometry, snowGlobeMaterial);
    scene.add(snowGlobe);

    // Création d'un objet central (par exemple, un arbre de Noël)
    //const treeGeometry = new THREE.ConeGeometry(1, 3, 8);
    //const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x006400 });
    //const tree = new THREE.Mesh(treeGeometry, treeMaterial);
    //tree.position.y = -1.5;
    //snowGlobe.add(tree);
    const wireMat=new THREE.MeshBasicMaterial({
        color : 0xffffff,
        wireframe : true
    })
    const wireMesh = new THREE.Mesh(snowGlobeGeometry,wireMat)
    snowGlobe.add(wireMesh)
    scene.add(wireMesh)

    // Création des flocons de neige
    const flakeCount = 100;
    const flakes = new THREE.Group();
    snowGlobe.add(flakes);

    // Géométrie et matériau des flocons
    const flakeGeometry = new THREE.PlaneGeometry(0.1, 0.1);
    const flakeMaterial = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide,
    });

    // Fonction pour vérifier si un point est à l'intérieur de la boule
    function isInsideSphere(x, y, z, radius) {
      return (x * x + y * y + z * z) <= (radius * radius);
    }

    // Création des flocons
    for (let i = 0; i < flakeCount; i++) {
      const flake = new THREE.Mesh(flakeGeometry, flakeMaterial.clone());

      // Position aléatoire à l'intérieur de la boule
      const radius = snowGlobeRadius * 1.2; // Rayon légèrement inférieur à celui de la boule
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      // Position initiale à l'intérieur de la boule
      flake.position.x = radius * Math.sin(phi) * Math.cos(theta);
      flake.position.y = radius * Math.sin(phi) * Math.sin(theta);
      flake.position.z = radius * Math.cos(phi);

      // Taille aléatoire
      const scale = 0.9 + Math.random() * 0.1;
      flake.scale.set(scale, scale, scale);

      // Vitesse de chute aléatoire
      flake.userData = {
        speed: 0.01 + Math.random() * 0.03,
        rotationSpeed: (Math.random() - 0.5) * 0.02,
        swaySpeedX: (Math.random() - 0.5) * 0.01,
        swaySpeedZ: (Math.random() - 0.5) * 0.01,
      };

      flakes.add(flake);
    }

    // Ajouter une lumière ambiante
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // Ajouter une lumière directionnelle
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const gltfLoader = new THREE.GLTFLoader();

// Charger un modèle 3D
//gltfLoader.load(
//  'textures/chess.glb',
//  (gltf) => {
//    const model = gltf.scene;
//    model.scale.set(8,8,8);
 //   model.position.y = -2;
//    snowGlobe.add(model);
//    console.log("gltf loaded")
//  }
//);

    // Animation
    function animate() {
      requestAnimationFrame(animate);

      // Faire tourner la boule à neige lentement
      snowGlobe.rotation.y += 0.002;
      wireMesh.rotation.y += 0.002;

    

      // Animer les flocons de neige
      flakes.children.forEach(flake => {
        // Faire tomber le flocon
        flake.position.y -= flake.userData.speed;

        // Faire tourner le flocon
        flake.rotation.z += flake.userData.rotationSpeed;

        // Balancement latéral
        flake.position.x += flake.userData.swaySpeedX;
        flake.position.z += flake.userData.swaySpeedZ;

        // Vérifier si le flocon est sorti de la boule
        if (!isInsideSphere(flake.position.x, flake.position.y, flake.position.z, snowGlobeRadius * 0.9)) {
          // Replacer le flocon à une position aléatoire à l'intérieur de la boule
          const radius = snowGlobeRadius * 0.8;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          flake.position.x = radius * Math.sin(phi) * Math.cos(theta);
          flake.position.y = radius * Math.sin(phi) * Math.sin(theta);
          flake.position.z = radius * Math.cos(phi);
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Gestion du redimensionnement de la fenêtre
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
